```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
```

# 模拟
模拟问题一般会与生活中的实际需求相对应。现实生活是多样的，因此其所对应的逻辑自然也是复杂的。正因如此，模拟题一般不会卡算法的复杂度，在面对一道模拟题的时候，我们需要做的不是优化计算速度，而是**尽量顾及到整个过程的方方面面，不要出差错**。

# 简单模拟

简单模拟照着做就是了，但时刻需要注意细节。比如数学题要注意循环边界，以及运算过程中有没有可能出现除零的情况。方阵图相关的模拟要注意不要越界。

为了使整个过程清晰不易出错，**建议把进行不同功能的代码块分别写成不同函数**，最终在主要的处理过程中调用各个函数即可，这并不会带来多大的开销（尤其是声明为inline的时候），但会使得程序的可读性大大提升，查错的时候也方便许多。

## P2670 扫雷
扫雷游戏是一款十分经典的单机小游戏。在n行m列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。输入数据第一行为雷区的行数和列数。在接下来输入的图中使用\*代表雷，?代表非地雷格。

### 需要用到的变量


```c++
namespace a{
    int row, col;
    char graph[101][101];
    const int dire[][2] = {{-1, 0},{-1, 1},{-1, -1},{0, 1},{0, -1},{1, 0},{1, 1},{1, -1}};
    // 相对于当前位置的偏移量
    //一般处理有关方阵图的时候，都会用得到这个数组（个人习惯）
}
```

### 输入部分


```c++
cin>> a::row >> a::col;

for(int i = 0; i < a::row; i++){
    for(int j = 0; j < a::col; j++)
        cin>>a::graph[i][j];
}
```

     3 3
     *??
     ???
     ?*?


### 一些很方便的函数


```c++
inline bool is_valid(int x, int y){
    return x >= 0 && x < a::row && y >= 0 && y < a::col;
}
//判断位置是否合法
//直接写在if里也可以，但写成inline函数看着舒服一点
```


```c++
int count(int x, int y){
    int res = 0;
    for(int i = 0; i < 8; i++){
        int a = x + a::dire[i][0], b = y + a::dire[i][1]; 
        //令当前位置加上偏移量
        if(is_valid(a, b)){
            if(a::graph[a][b] == '*')res++;
        }
    }
    return res;
}
```

### 最终过程


```c++
for(int i = 0; i < a::row; i++){
    for(int j = 0; j < a::col; j++){
        if(a::graph[i][j] == '?')a::graph[i][j] = count(i, j) + '0';
        cout<<a::graph[i][j];
    }
    cout<<endl;
}
```

    *10
    221
    1*1


# 查找&排序

排序题一般会有这样一个特点，即**需要排序的对象具有多个属性**，我们需要根据这些属性中的某一种属性来排序，然后输出另一种属性。那这时候，结构体（struct）就显得格外有用。我们可以通过**重载小于运算符**（或自定义一个比较函数，接收两个struct对象的引用返回一个bool值）的方法来指定一个结构体对象的排序方式（利用哪些属性进行比较？这些属性之间的比较方式是什么样的？），而在输出的时候则指定我们需要输出的属性即可。

查找的过程比较简单，我们预先将pos设为-1，遍历一遍需要进行查找的数组，如果遍历到的元素与所需要查找的元素相同则将pos设为该元素下标；否则最终输出-1，代表没有找到。遍历法对于数据规模较小的情况适用，对于大数组，可以考虑使用其他查找方法，比如二分查找或者利用接下来其他同学讲到的哈希进行查找。或者借用一些数据结构，比如查找树。

## P1093奖学金
每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。

请给出排名最靠前的5位学生的学号和总分。


```c++
namespace s{
    int n;
    struct stu{
        int ser;
        int Chinese;
        int Math;
        int English;
        int sum;
        
        //定义‘小于’的比较方法，用于排序
        bool operator<(stu& oth){
            if(sum == oth.sum){
                if(Chinese == oth.Chinese){
                    return ser > oth.ser;
                } else return Chinese < oth.Chinese;
            } else return sum < oth.sum;
        }
    }all[300+10];
}
```


```c++
cin>>s::n;
for(int i = 0,a,b,c; i < s::n; i++){
    cin>> a >> b >> c;
    s::all[i].ser = i + 1;
    s::all[i].Chinese = a;
    s::all[i].Math = b;
    s::all[i].English = c;
    s::all[i].sum = a + b + c;
}
```

     6
     90 67 80
     87 66 91
     78 89 91
     88 99 77
     67 89 64
     78 89 98



```c++
sort(s::all, s::all + s::n);
//STL排序，也可以自己手写排序
for(int i = 0; i < 5; i++){
    cout<< s::all[s::n - 1 - i].ser << ' ' << s::all[s::n - 1 - i].sum <<endl;
}
```

    6 265
    4 264
    3 258
    2 244
    1 237


排序的依据有很多，比如这道题的多重比较，一个条件比不出来就换另一种。对于字符串来说，我们也有一种类似的比较方法：字典序（lexicographical order）。就像翻字典一样，我们先从第一个字符开始比较，如果无法比较出结果则比较下一位，直到比较出结果，或者到达字符串结尾。

容易发现，对于一个自然排列（比如12345），我们将他的字典序从小到大依次输出，得到的结果就相当于是它的全排列。既然如此，我们就可以通过模拟字典序比较的方法来求出任意一个排列的下一个排列（即字典序比当前排列大1的排列）：
1. 从尾到头寻找第一个这样的数字，即它右边的数字比它本身还要大，将这个数字记为a，所在位置为i。
2. 从尾到头寻找第一个这样的数字，即这个数字比a要大。
3. 交换两个数字的位置。
4. 将i后面的部分进行排序。

具体的程序实现请诸位自行实现。

对于得到的结果，我们可以使用algorithm库中的next_permutation函数来验证。

在C11的string中，字符串之间默认的比较方法就是字典序。

# 日期相关的问题

日期相关的问题让人很头疼，因为现实中对于历法的规定就是如此混乱不堪（比如1582年10月4日的下一天是1582年10月15日）。但没办法，我们只能按照这些规矩来写我们的程序。对于闰年，我们使用is_leap函数判断，而对于每月的不同天数，我们使用一个month[13]数组存储（建议开为13，这样的话可以让下标与月份对应）。

处理日期之间的相隔值时，我们可以采用这样的一种视角来看待日期，即**把日期看作是一种特殊进制的数字**，它的个位（秒）向十位（分）进位时遵从60进制，百位（时）向千位（天）进位遵从24进制……对于特殊情况（闰年）则加以特判。

### 例： 给定两个年月日，输出其之间相差的天数。

比如，给定两个日期：2020-04-21，2020-05-01

输出其所差的天数：10。


```c++
namespace b{
    int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    //每月的天数，其中二月为平年的天数
    
    struct date {
    int year;
    int mon;
    int day;
    bool is_leap() { return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0); }

    date(int y, int m, int d) : year(y), mon(m), day(d) {}
        
    void operator+=(int d) {
        int a, b;
        int md = (mon == 2) ? (month[mon] + is_leap()) : month[mon];
        //如果是2月，则判断是否是闰年，如果是闰年就加上一天
        a = (day - 1 + d) / md;
        //对月份的进位
        day = (day - 1 + d) % md + 1;
        b = (mon - 1 + a) / 12;
        //对年份的进位
        mon = (mon - 1 + a) % 12 + 1;
        year = year + b;
    }

    bool operator!=(date& oth) {
        return !(year == oth.year && mon == oth.mon && day == oth.day);
    }
};  
}
```


```c++
b::date d1(2020, 4, 21), d2(2020, 5, 1);
int res = 0;
while (d1 != d2) {
    res++;
    d1 += 1;
}
cout << res << endl;
```

    11


除此之外我们还可以利用另一种思路，即求出两个日期相对于某个特定日期的单位时间差值（这里的单位时间我们一般采用秒），然后将得到的两个单位时间数量相减即可得到这两个日期之间相差的单位时间数量了。

UNIX系统中所采用的UNIX时间就是通过这种思路来实现的。一个UNIX时间戳定义为一个指定的日期与1970年1月1日所相差的秒数。在求任意两个日期之间的秒数时，我们只需要将他们的时间戳相减即可。

# 图形输出

## 1. 根据图形的规律来逐行进行输出
这种图形输出题目一般具有显著的数学规律。在编写时，我们需要找到**每一层的字符相对于层数的数学表达式**，然后按照表达式的结果依次输出即可。

在寻找表达式的过程中，我们需要注意行数的数字特征与图形之间的联系，比如当行数是奇数的时候是一种状态，偶数的时候是另一种状态等等，以及对于特殊情况的特判。
### 例：画个漏斗吧！n代表漏斗最上层*的个数。


```c++
例如，当n = 11时：
***********
 *********
  *******
   *****
    ***
     *
    ***
   *****
  *******
 *********
***********
```

通过观察可以得到如下特征：
1. 图形上下对称，因此只看上半部分就行了，下半部分的实现大同小异
2. 每层开头的**空格数依次递增一个**，总字符数**依次递减一个**

因此根据这两个特征，我们只需要计算出每层的空格数和总字符数，然后按照规律输出字符就可以了。


```c++
namespace c {
    int n;
}
```


```c++
cin >> c::n;
```

     15



```c++
for(int i = 0; i < c::n/2; i++){
    for(int j = 0; j < c::n - i; j++){
        if(j < i)cout<< ' ';
        else cout<< '*';
    }
    cout<< endl;
}
cout<<setw(c::n / 2 + 1)<< '*' <<endl;
for(int i = c::n/2 - 1; i >= 0; i--){
    for(int j = 0; j < c::n - i; j++){
        if(j < i)cout<< ' ';
        else cout<< '*';
    }
    cout<< endl;
}
```

    ***************
     *************
      ***********
       *********
        *******
         *****
          ***
           *
          ***
         *****
        *******
       *********
      ***********
     *************
    ***************


## 2. 定义字符数组，通过图形规律来填充数组，最终输出

这种方法跟上面的大同小异，区别在于图形的规律可能不仅仅是跟行数相关这么简单了，可能涉及到更复杂的方面，比如列数、图形之前的状态等等。既然如此，我们就把图形存储在一个足够大的字符数组中，等到处理完成后再统一输出即可。

### P5461赦免战俘

现在有一个$2^n \times 2^n$的全部为1的方阵，我们需要将这个方阵分为四个小方阵，然后将左上角的那个方阵全部变为0，其余的三个再分为四个方阵，将左上角变为0……

请输出经过这样的变换之后，最终的图形。

解： 需要用到递归的思想。对于一个方阵，我们先将其左上角全部变为0，然后再依次用同样的方法处理其余的三个部分。


```c++
namespace d{
    char graph[1145][1419];
    //初始的数组要开的足够大，要不然有可能会越界
    int n;
}
```


```c++
void set_zero(int x, int y, int length) {
    if (!(x || y))
        for (int i = 0; i < length; i++) fill(d::graph[i], d::graph[i] + length, '1');
    //初始化

    if (length == 1) return;
    //递归边界

    for (int i = x; i < length / 2 + x ; i++)
        for (int j = y; j < length / 2 + y ; j++) d::graph[i][j] = '0';
    //左上角置零

    int l = length / 2;
    set_zero(x, y + l, l);
    set_zero(x + l, y, l);
    set_zero(x + l, y + l, l);
    //递归处理其余部分
}
```


```c++
cin >> d::n;

int l = pow(2, d::n);
set_zero(0, 0, l);
for (int i = 0; i < l; i++) {
    for (int j = 0; j < l; j++) cout << d::graph[i][j] << ' ';
    cout << endl;
}
```

     3


    0 0 0 0 0 0 0 1 
    0 0 0 0 0 0 1 1 
    0 0 0 0 0 1 0 1 
    0 0 0 0 1 1 1 1 
    0 0 0 1 0 0 0 1 
    0 0 1 1 0 0 1 1 
    0 1 0 1 0 1 0 1 
    1 1 1 1 1 1 1 1 


当然也可以试试递推。我们很容易就能写出当n = 1时的情形，通过这一点来推出下一个图形的样子：下一个图形的左上角全部为0，而其余部分则复制自其之前一个图形的样子。

# 进制转换

一些基础知识：
我们知道，一个数字在n进制下的表示相当于
$$
(a_ka_{k-1}a_{k-2}\dots a_0)_{(p)} = a_0\times p^0+a_1\times p^1+\dots+a_kp^k
$$
因此进制转换的本质在于将这个式子看成另一种进制下的一个算式。比如$110_{(2)}$在10进制下就相当于$1\times 2^2 + 1\times 2^1 + 0\times 2^0 = 6$。

## n进制转十进制


```c++
#define ll long long
ll to_dec(ll num,int pos = 2){
    ll res = 0;
    ll p = 1;
    while(num){
        res += (num % 10) * p;
        num /= 10;
        p *= pos;
    }
    return res;
}
```


```c++
ll to_dec_s(string num, int pos = 2){
    ll res = 0;
    ll p = 1;
    for(int i = num.length() - 1; i >= 0; i--){
        res += (num[i] - '0') * p;
        p *= pos;
    }
    return res;
}
```


```c++
cout<< to_dec(114514, 6) <<endl;
cout<< to_dec_s("114514", 6) <<endl;
```

    10126
    10126


## 十进制转n进制


```c++
ll to_oth(ll num, int pos){
    ll res = 0;
    ll p = 1;
    while(num){
        res += (num % pos) * p;
        num /= pos;
        p *= 10;
    }
    return res;
}
```

字符串形式的转换函数留做习题。


```c++
cout << to_oth(114, 2) <<endl;
```

    1110010


对于数据规模较小的情况，利用int类型存储其他进制的数字并无不妥；但一旦数字过大（比如二进制11010111001010）或者进制超过10（比如十六进制），这种方法就颇有局限性。因此建议使用string表示其他进制数字。

其实对于十进制转二进制，我们还可以采用位运算的方式：


```c++
string dec_to_oct(int num) {
    string res = "";
    unsigned p = 1 << (int)(log2(num) + 1);
    while (p >>= 1) res += (num & p) ? "1" : "0";
    return res;
}
```

借助掩码p，我们将num的二进制表示中的每一位提取出来，组合在一起即为num的二进制表示。

## 为啥一定要用十进制

十进制也不是啥天选之子，只是因为如果将一种进制转为十进制再转为其他进制的话，转换过程中的加法就都可以让编译器帮咱们实现。如果你契而不舍地手写了其他进制的加法，那自然就可以直接进行进制转换，原理是一样的。

# 字符串处理

常见的问题包括查找字串位置，字串替换，统计字串数量，字符串格式化等等。
根本在于理解清楚题目要求，且时刻注意字符串处理的常见问题（如缓冲区残留的换行符等等）。

常用的处理技巧：我们一般认为两个空格之间的部分叫做一个单词，但一个句子的开头和结尾一般没有空格，因此判断第一个和最后一个单词麻烦一些。我们可以预先给每个字符串的开头和结尾添加上空格：
```c++
string a;
getline(cin, a);
a = ' ' + a + ' ';
```
这样就可以用一种统一的方法来辨别出所有单词了。

## P1308统计单词数

给定一个单词和一行字符串，统计该单词在字符串中第一次出现的位置和单词总共出现的次数，如果没有找到则返回-1。不区分大小写。

需要干的事情:
1. 由于不区分大小写，得有个办法**把一个单词全都变为小写**
2. 辨别两个单词是否完全相同


```c++
namespace r {
char voc[100];
char str[1000010];
int res = 0,pos = -1;
}
```


```c++
void tolower(char* str, unsigned size) {
    for (int i = 0; i < size; i++) 
        if (str[i] >= 'A' && str[i] <= 'Z') str[i] += 32;
}
```


```c++
bool is_match(char* v, char* s, unsigned size) {
    tolower(s, size);
    for (int i = 0; i < size; i++)
        if (v[i] != s[i]) return 0;
    return 1;
}
```

输入部分


```c++
cin.getline(r::voc, 100, '\n');
cin.getline(r::str, 1000010, '\n');
unsigned lv = strlen(r::voc), ls = strlen(r::str);
tolower(r::voc, lv);
```

     To
     to be or not to be is a question



```c++
unsigned t = 0;
//用于暂存主串中每个单词的长度
for (int i = 0; i <= ls; i++) {
        if (i == ls || r::str[i] == ' ') {
            //短路特性
            if (t == lv && is_match(r::voc, &r::str[i - t], lv)) {
                //先判断单词是否等长，如果等长则检查它们是否完全相同
                r::res++;
                if (r::pos < 0) r::pos = i - t;
                //记录单词开头的位置
            }
            t = 0;
            while (r::str[i + 1] == ' ') i++;//跳过空格
        } else
            t++;
    }
    if (!r::res)
        cout << -1 << endl;
    else
        cout << r::res << ' ' << r::pos << endl;
```

    2 0


更普遍的操作可以使用有限自动机，这部分不在此进行展开。
